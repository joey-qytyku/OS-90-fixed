================================================================================
	Miscelaneous yet important details before you start.
================================================================================

--------------------------------------------------------------------------------
	NULL Is Not Zero!
--------------------------------------------------------------------------------

In OS/90, NULL is actually 0xFFFFFFFF because 0 is a valid address. 0xFFFFFFFF is an unmapped.

This MUST be taken into consideration. E.g. structures like linked lists with NULL pointers cannot just be zeroed unless the zero is given special meaning by checking it. Otherwise, a NULL dereference cannot be an error.

The C standard defines NULL as the pointer version of the integer zero. It can be compared using if statements. If the pointer is in a boolean expression, it is false if NULL. But OS/90 does not use NULL the same way.

NULL is still but it is non-standard and aliases OSNULL. It may need to be casted for double pointer types.

Attempting to dereference an OSNULL pointer is a critical error that must never occur under normal circumstances. Because drivers are really just kernel extensions, they cannot be terminated.

This has no noticable impact on code density. Even comparisons are abbreviated in x86 for long operands, along with signed immediate push operations.

--------------------------------------------------------------------------------
	C99 and SysV i386 Compliance
--------------------------------------------------------------------------------

OS/90 is written to be compatible with the GNU dialect of C99. This is not advertised, but is a general principle.

C99 introduced the strict aliasing rule, by which it is potentially dangerous to cast a pointer of one type to another and access overlapping data.

The SysV ABI is generally used. Structure layouts and most calling conventions conform to the rules found in this specification because GCC already adheres to it internally.

Some examples:
................................................................................
DWORD PTR p1;
DWORD CTR p2;

WORD CPTR_CDR p3; // Constant pointer to constant data + restrict
................................................................................

This is easier than writing const once or twice, or restrict.

DWORD const*const __restrict => 28 chars
DWORD CPTR_CDR               => 14 chars

Use restrict to relax alias checking for same-type arguments or in structures with the same thing.

In the context of a function, restrict means that the pointers are expected to not overlap. If there is only one argument of a specific type,

--------------------------------------------------------------------------------
	Strict Aliasing in Detail
--------------------------------------------------------------------------------

Pointers of different types should never alias. The compiler gives some warnings.

The following link is an article that summarizes the issue in greater detail:

TLDR:
* It cannot always be assumed that integer types do not alias if a stdint type is used with an integral one. `int8_t*` could be the same as `char*` and the compiler will consider that to be an alias.
* Some compilers make very strong assumptions that different pointer types never alias.
* This creates problems with malloc if it has a different name because it returns void and can be converted to more than one typed pointer that could be assumed non-aliasing by the compiler.
* C99 does things differently and potentially breaks C89 code.

--------------------------------------------------------------------------------
	Atomic Operations
--------------------------------------------------------------------------------

Never use volatile. Ever. Some people use it to access framebuffers because the compiler will not do anything strange with the ordering, but the definition of volatile is not entirely clear to many. It is not a proper memory fence.

GCC will not generate the most optimal code for volatile. It tends to load before changes.

Compilers do not reorder function calls, even if they are inline, if there are side effects, such as if the memory clobber is specified, which is correct.

Use proper utilities for this. All are in "type.h".

--------------------------------------------------------------------------------
	Configuration File
--------------------------------------------------------------------------------

The configuration follows the same general format as the one used by DOS. Only KEY=OPTION is supported and only CRLF should be used.
