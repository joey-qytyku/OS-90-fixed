# OS/90 DOS+DPMI Compliance Strategy

OS/90 is DPMI-compatible and supports most 1.0 features (with some exceptions). It reports 0.9 unless configured otherwise. it also is capable of simulating 16-bit DOS.

DOS interface implementations are separated from most other components.

This document will be mostly useless for most OS/90 developers. It is for any notes that cannot be yet inlayed into source comments.

# DOS Virtual Machines

## Program Segment Prefix

The PSP has many components that must function as expected. It is needed for some program-local operations.

The entire get/set current PSP interface is fully hijacked. I do not know if DOS tries to access this interface????

### Environment Segment

The environment will usually be initialized by the command interpreter. It is nothing more than a region of memory, which in our case is isolated for each VM, that contains string data set up by `AUTOEXEC.BAT`. Changes to the environment require restarting the command interpreter.

In cases where a program is executed without COMMAND.COM starting it up, ENV will be empty and preallocated to the size explicitly requested.

> It is impossible to use a shared environment. This noramlly increases memory usage.

### Job File Table

> Some programs try to change the JFT though. Windows probably does.

Here is how DOS file handles work:
- The system file table keeps a linked list of every unique open file
- The address of a SFT entry cannot serve as a handle because handles can be duplicates and point to the same file.
- The JFT serves as a table of indices

Making the JFT actually local is not useful and makes it harder to perform IO from kernel mode drivers.

OS/90 considers the JFT to be global. It is resized to 255 handles. Creating new programs will not change the JFT references.

Each PSP has an address to the JFT and it does not have to be the default one, which keeps compatibility.

The JFT's first entries are:
- stdin (0)
- stdout (1)
- stderr (2)
- com1 (3)
- lpt (4)
- Rest are FF

> Do not confuse the JFT with the FILES=x directive in CONFIG.SYS. This actually refers to the SFT.

### Critical, ^C, and Exit Addresses

These are techically old features that should not be relied upon.

### File Control Blocks

OS/90 does not support file control blocks. This is fine since Windows 95 also does not fully support them.


### Disk Transfer Area

A DTA is provided by default and the internal DTA address is set to this location.

### Call 5

This interface is supported. Some programs depend on it. Call 5 simply calls INT 21H.

### Command Line

Automatically generated by executing program.

### Internal Parent PSP Segment

DOS esentially executes programs like a stack. This is the PSP of the task that executed the current one.

### Segment of First Byte

DOS programs are totally contigious in memory upon initial execution.

## System File Table

As stated previously, the SFT is still required to be used. Windows expects its presence.

## Handling of Subprograms

The interface for creating subprograms is controlled by the OS and the entire executable loader is reimplemented in the kernel.

Subprograms get complicated when DPMI is involved. The specification is not very specific, but I have been able to run DJGPP from a command prompt spawned by RHIDE. This indicates that nested instances of DOS programs do work, and they CAN in fact enter protected mode on their own.

A new task is created for subprograms, but the invoking program.

## Conventional Memory

OS/90 uses a single address space for DOS. The conventional memory is unpagable and therefore limited in all situations to 640K. This can be a problem for some demanding games that could need up to 500K in order to run properly.

The memory manager of DOS is used. Best fit allocation strategy is used.

Conventional memory is deliberately underreported. The invocation function takes the number of kilobytes to permit the program to allocate (not immediately). If the program is a `.COM`, it normally would need the entire conventional memory but this not possible, so allocated memory on startup is restricted to the size of the COM file.

## XMS Emulation

Each VM gets a certain number of XMS handles which are non-sharable between VMs. A simple lookup table with 24-bit compressed chain IDs is used.

## EMS Emulation

OS/90 cannot tolerate the exisitence of EMM386.

Expanded memory is a very ugly API that I have little interest in implementing. If I can adapt some existing code, it could happen.

## Context In General

OS/90 uses scheduler tasks to run DOS virtual machine. The distiction is that tasks can belong to a VM as threads of execution, while VMs are simply "instances" of the partially-simulated operating system.

The VM context contains:
```
Full PSP
Local Ctrl-C and critical error handlers
Local system idle loop handler
Local interrupt vector table

Current drive
Current path

Conventional memory context
LIMulation context
Virtual text mode framebuffer
INT 21h STDIO callbacks
DTA address

Pointer to first child VM
```

# DPMI

OS/90 reports DPMI 0.9. The implementation is not planned to support 1.0 features to any extent further than being able to run Win16 or the OS/90 UI.

Some additional interfaces are also added to access unique OS/90 functionality not supported by any other OS.

This section will explain how OS/90 implements each DPMI function call and explains any extensions to or deviations from the standard.

## 32-bitness and 16-bitness

OS/90 DPMI is very soft when it comes to enforcing bitness. Function calls that are normally not supported in 16-bit clients are supported under OS/90 with the expectation they are not used.

If extended registers are used to address program memory, bitness will be considered to ensure proper program behavior. The bitness of a program is constant throughout its execution and extended registers MUST be used for arguments if the client is 32-bit, even if the current code segment is 16-bit.

The general rule of thumb is that 16-bit and 32-bit clients will run "as expected" with no unusual behavior if the program does not rely on bitness-related errors, which will essentially never occur.

## LDT Services

### Allocate LDT Descriptors (0000)

Because DPMI programs can set LDT entries manually, a separate bit array is used to allocate LDT entries.

### Free LDT Descriptor (0001)

### Segment to Descriptor (0002)

Allocates a descriptor and maps it to a real mode segment. Fairly simple. Multiple calls must return the same selector, but it is uncertain how many programs rely on such functionality; OS/90 does not comply in this regard.

Descriptors allocated by this are supposed to be impossible to free, but this is not a limitation on OS/90.

### Get Selector Increment Value

This is a value that when added to a range of allocated descriptors, gets it up to the next increment. This is 8.

The reason why this API call exists is because running DPMI in a different ring could cause the number to be different?

### Get/Set Descriptor (000C, 000D)

This maps almost directly to actual descriptors, but non-ring-3 descriptors are not allowed.

### Allocate Specific Descriptors

These work as expected. The first 16 LDT descriptors are reserved for specific descriptors.

## Extended Memory Services

### Get Free Memory Information (0500)

DPMI recognizes the following attributes of extended memory, reported by function `0500h`:
1. Largest available free block in bytes
2. Maximum unlocked page allocation in pages
3. Maximum locked page allocation in pages
4. Linear address space size in pages
5. Total number of unlocked pages
6. Total number of free pages
7. Total number of physical pages
8. Free linear address space in pages
9. Size of paging file/partition in pages

OS/90 does NOT report swap space to the program. It is none of its business. Swap space is virtual memory and reports as regular allocatable pages.

# Microsoft Extensions

OS/90 supports extensions for DOS as specified by leaked Microsoft documents, which should permit running 16-bit Windows under it. This permits protected mode to call 16-bit real mode functions.

## Reflection Strategy

I want the ability to implement entire API calls using the direct context of the protected mode call. For example, a call to INT 21H AH=9 can be totally handled in PM using the segments as expected, while real mode can use a different tactic.

To do this, PM reflection and RM reflection will NOT handle PM extensions. Instead, it will be an SV86 global hook. The real mode reflection handler will pass down a PM context and the SV86 handler must capture this.

Suppose INT 21H AH=9.

- INT is received by exception handler
- Looks for local PM handler
- Finds none, passing to real mode
- No local real mode handler
- SV86 captures and finds out this is a PM context.
- If within the jurisdiction of extensions, it will be translated.
- If NOT, the call is carried out noramlly by the SV86 handler assigned

INT 21H will have an SV86 handler that is global. INT 13H will have one too since the API does support extensions.

If protected mode drivers want to hook something like INT 13H, it can work just fine, but it requires acknowledgement of extensions. The SV86 handler could be passed a protected mode context, and the only way to know is by checking the VM bit. If it was protected mode, it has to handle it differently.

The default SV86 handler for the INTs will copy the context to another one, and will do so directly using the registers of the calling task.

This makes writing drivers that use SV86 hooks kind of annoying. INTxH will automatically set the VM bit, so it is not that bad. Register-based APIs do not have to worry about handling PM.

Suppose I create an unrealistic AH=9 hook:
```
V86_HOOK INT21H_AH_9(PSTDREGS r)
{
    if (!(r->EFLAGS & FLAGS_VM)) {
        // In protected mode
        char __far *msg = MK_FP32(r->ds, r->edx);
        int i;
        for (i = 0; msg[i] != '$'; i++)
            putchar(msg[i]);
    }
}
```

This is obviously not how it should be done but illustrates the idea. Nobody would ever call INT 21H AH=9 directly in normal DPMI, and if they did, it would not work properly. On OS/90, it would. The PM call in both instances has the entire contexted passed to a real mode reflection callee. In our case, an extra layer exists that makes it work when it normally would not.

Note that this code is completely impractical. It is meant to highlight that the protected mode context can be received and detected for extensions.

## Things To Support

Most of the APIs are fairly straightforward to extend, but there are a few that need special considerations.

### Get/set PSP

# DOS Memory Policy In Detail (TODO)

## Conventional Memory

This is something that should be user-configurable, and it is when starting the VM.

The recommendation is that only about 75% of the available conventional memory, but the create interface has full control.

## Environment Segment

Each program has its own environment. The size must be adjusted.

# Unsupported Interfaces

## Virtual DMA Services
> https://web.archive.org/web/20121022073637/https://support.microsoft.com/kb/93469

There are currently no plans to support VDS. Programs that use DPMI usually allocate their own memory for it, generally conventional. Windows has a VxD for simulating DMA. OS/90 has a driver for emulating DMA as well, with partially arbitrated access.

There is little need for this interface. As far as I know, few programs ever used it.

## DOS Protected Mode Services (DPMS)

This API is independent of DPMI or VCPI and can use both. It allows for resident drivers to run in protected mode. Not currently supported. Existing implementations may still be able to run on top of built-in DPMI.
