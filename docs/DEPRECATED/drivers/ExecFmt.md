# New Changes

The symbol table and external relocations will be removed entirely and replaced with a single kernel API call table

# ELF Simplified Subset (ESS)

ESS is called "simplified" because it uses executable information from the ELF i386 format without actually being elf, therefore making ESS a subset. It is a product of my complete aversion to designing a real executable loader in the kernel.

Drivers are ESS files.

## Linker Tricks

Undefined references to symbols cannot be detected during the link time and are instead detected by the loader. The linker is instructed to ignore undefined references with the `--unresolved-symbols=ignore-all` option.

The value in memory will be relative to the relocation addend when loading from the executable.

## Structure of ESS Executables

### ESS Header

Seven sections are used by ESS:
* .text
* .data
* .bss
* .rela.text
* .rela.data
* .symtab
* .strtab

In C notation:
```
tstruct {
    DWORD   magic;

    struct {
    DWORD   text;
    DWORD   data;
    DWORD   bss;
    DWORD   rela_text;
    DWORD   rela_data;
    DWORD   symtab;
    DWORD   strtab;
    }rva;

    struct {
    DWORD   text;
    DWORD   data;
    DWORD   bss;
    DWORD   rela_text;
    DWORD   rela_data;
    DWORD   symtab;
    DWORD   strtab;
    }bytes;

    DWORD   entry;
}ESS_HEADER;
```

The size of a section is measured in bytes. This allows strtab and symtab to be allocated at once and with lower granularity than that of a page, reducing used memory when loading the executable. For executable data sections, this does not do anything.

### Toolchain

The code in the executable needs to be page aligned. Because we are generating a flat binary, putting executable data right after a non-page-granular header is not possible. There is a solution through, and it is to put it though another layer of processing.

A program named ESSPREP, which is designed for Unix hosts, will generate the final downsized executable. The addresses at the end of the file are relative to a base-zero executable with no aditional data at the start. The process is simply to copy the information into a header at the start of a new file and the rest of the data goes directly after.

### File Layout Overview

The final executable starts with the header. The three sections are independently relocated and are not page aligned or padded in the executable and still need to be processed. Memory is allocated at once by the loader because the header is enough to determine the memory requirements of the executable.

BSS does not get a relocation table for reasons that should be apparent.

### Undefined Symbols

It is necessary to paste in symbols from the kernel API. This means that the symbol table is not enough. We need to know every reference to the symbol.

A relocation table entry with the type R_386_PLT32 is used to locate undefined procedure references. Relocations of this type use a symbol index so that each reference to the symbol can be located and replaced.

Relocations are section relative. We can safely copy them into the final executable.

### Full Driver Build Process

1. Translation units are generated by the compiler/assembler
2. Local symbols are removed from the object file with the command `objcopy --strip-local`
3. Object files are then merged into one object file using `ld -r`. This prevents duplicate symbols.
4. The linker script is used to generate the flat binary.
5. Finally, `essprep` moves the header to the start of the file.

### Loading Process and DRVPREP.EXE

Replacing symbols is a very slow process. For every symbol in the kernel export table, we scan the driver symbol table to get the symbol index. Then we search every relocation and see if it type R_386_PLT32 and the index is the same. If so, we replace this symbol with the kernel value.

This it very slow and bad for boot times.

To improve the performance we can perform this process statically by preprocessing the driver with a special program that runs under DOS. It will perform the symbol part of the loading process and insert dummy relocations in the place of R_386_PLT32. DRVPREP needs to be provided the path of the kernel image.

The export table is made of two parts: string table and symbol table.

### Entry State

For userspace, the program will start running at the entry point. For drivers, the entry point is the Driver Descriptor Block.

Drivers do not get their own stack. For initializing, the loader stack will be used. For ISRs or anything servicing a system entrance, whatever the current kernel stack is will be the one used.

All registers are undefined. BSS is automatically zeroed. Memory is allocated at once by the loader because the header is enough to determine the memory requirements of the executable.

BSS does not get a relcation table for reasons that should be apparent.

### Undefined Symbols

It is necessary to paste in symbols from the kernel API. This means that the symbol table is not enough. We need to know every reference to the symbol.


A relocation table entry with the type R_386_PLT32 is used to locate undefined procedure references. Relocations of this type use a symbol index so that each reference to the symbol can be located and replaced.
ecutable and still need to be processed. Memory is allocated at once by the loader because the header is enough to determine the memory requirements of the executable.

BSS does not get a relcation table for reasons that should be apparent.

### Undefined Symbols

It is necessary to paste in symbols from the kernel API. This means that the symbol table is not enough. We need to know every reference to the symbol.

A relocation table entry with the type R_386_PLT32 is used to locate undefined procedure references. Relocations of this type use a symbol index so that each reference to the symbol can be located and replaced.

Relocations are section relative. We can safely copy them into the final executable.

### Full Driver Build Process

1. Translation units are generated by the compiler/assembler
2. Local symbols are removed from the object file with the command `objcopy --strip-local`
3. Object files are then merged into one object file using `ld -r`. This prevents duplicate symbols.
4. The linker script is used to generate the flat binary.
5. Finally, `essprep` move the header to the start of the file.

### Driver Installation Process

Driver executables are generated as .ESS files for sharing. These cannot be imported by the OS, even if the file is renamed to DRV beccause the kernel does not do the job of replacing symbols.

To set up a driver:
```
drvgen mydrv.ess
```

DRVGEN.EXE is a program that runs in 16-bit DOS but uses 32-bit features. It will go to the kernel and find the kernel export table. Then it will proceed with the entire linking process. It is written in C with the IA16 toolchain.

Once the ESS file has been linked against the kernel binary, this executable CANNOT be shared with other OS/90 installations safely and is almost garaunteed to fail across different builds.

### Entry State

For userspace, the program will start running at the entry point. For drivers, the entry point is the Driver Descriptor Block.

Relocations are section relative. We can safely copy them into the final executable.

### Full Driver Build Process

1. Translation units are generated by the compiler/assembler
2. Local symbols are removed from the object file with the command `objcopy --strip-local`
3. Object files are then merged into one object file using `ld -r`. This prevents duplicate symbols.
4. The linker script is used to generate the flat binary.
5. Finally, `essprep` move the header to the start of the file.

### Entry State

For userspace, the program will start running at the entry point. For drivers, the entry point is the Driver Descriptor Block.
