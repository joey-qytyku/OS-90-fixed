# Preface

OS/90 features a fully-preemptible and reentrant kernel. The scheduler is the most complex part of OS/90 because of the high degree of DOS compatibility and modern features built on top of it.

# Terms to Know

Virtual INT: A feature in OS/90 that allows the kernel thread to enter real mode to call a software interrupt vector. This is terminated by the IRET instruction at the highest INT call level.

Reentrant: The kernel can be entered by several concurrent threads at once. Locking is used to guard parts of the kernel that are shared or non-reentrant.

Trap frame and context: Read below

# PIT Configuration

Originally, 1MS scheduler ticks were considered, but when the kernel was made preemptive and reentrant, this was found to not be very high.

1MS means 1000 hertz. Let us suppose the average i386 runs at 20 MHz. Context switches are expensive operations.

# Interrupts and Exceptions

# Local Exceptions and Fake Interrupts

When any of these local asynchronous events take place, the scheduler will set a flag to indicate that the process is awaiting a fake IRQ or exception. On the next schedule of the process, it will change flow to enter that location.

If the program is in protected mode, a RETF frame is generated by the kernel so that the ISR can RETF back.

Knowing whether or not the process is busy processing an interrupt is the job of a device driver. The kernel will just call the vector.

The following exceptions may be hooked by DPMI programs:
* General protection fault
* Stack segment fault
* Divide by zero
* IRQ#13 or FPU error
* Debug
* Break
* Overflow
* Bound range
* Segment not present

#NP could be used by segmented model programs to implement segment swapping.

## Exceptions in Real Mode

Some programs trap exceptions such as divide by zero or FPU error. The local vectors are used for this if the entry has been set up properly.

IRQ#13 may be used to recieve FPU errors.

## IRQ#13

If a program sets this vector, it expects the FPU to be not be in native mode. The operating system will send FPU exceptions using the IRQ#13 vector.

# States of the CPU and Last Context Type (TODO)

The current context type is always known by the code running, but the kernel needs to know what it just switched out of.

The last context type can be:
* User
* Kernel
* Exception

# Processes

All processes are DPMI/DOS applications and can run in one of the following modes:
* Virtual 8086
* Protected mode 16-bit
* Protected mode 32-bit

A few DPMI functions are slightly different between 16 and 32-bit protected mode.

# What this Document is About

* How processes enter and exit the kernel
* Syhcronization
* Sending user-trapped events like IRQs and exceptions
* Virtual 8086 mode

# Synchronization

OS/90 makes use of non-reentrant locks. It is expected that all functions that require a lock to be acquired prior to calling document this. A function that acquires a lock should be the one that releases it.

# The Process Control Block

The PCB is 8192 bytes large and naturally aligned. It includes the stack and information about the process, both being 4096 bytes.

# Elevated Virtual 8086 Mode (SV86)

# Contexts

## Non-Preemptible Context

A non-preemptible context is a section of execution within kernel mode which cannot be interrupted by a user process. Entering one is done by inc/dec'ing the preempt counter (read below). Disabling interrupts implies a non-preemtible region. A non-preemtible context is the only type of context in which the trap frame can be safely read or written. Returning from the system entry and back to the original code is valid behavior.

SV86 and exceptions are non-preemtible contexts.

## Preemptible Context

Processes when in user or kernel mode are preemptible.

# TSS and IO Permissions

OS/90 supports emulation of IO instructions for userspace software, but when the kernel needs to run virtual 8086 mode to perform system tasks, IO must be directly sent to hardware. There are two ways of doing this.

IOPL is going to be 3 for all tasks no matter what. Even though the CPL is less than or equal to the IOPL, it is still necessary to have an IOPB with all zeroes (allow) or there will be a fault and the instruction will not be directly executed. The IOPB is 8192 bytes long, but gives real mode code a performance boost because instructions run directly. Or so it seems.

The other way to do it is to emulate all port IO. Decoding the instructions involves checking bits in the opcode that reveal different attributes, such as direction, imm8 or DX, or string/no string. These bits are not documented, but have predictable meanings and make decoding nothing more than a few condition checks and bit masks.

Directing them to real IO operations is a different story. We decode because emulating every possible instruction sequence would not be dense enough.

## Decision

The TSS may be a very large structure with the IOPB, but we will use it to simplify the IO virtualization functionality. Interpreting the IO instructions would cause the system to crawl during IO. 8K of memory is the cost of better performance.

But IO opcodes are faster in ring-0 protected mode because they do not need to access the IOPB or check IOPL. String instructions justify emulation overhead. Protected mode IO is apparently faster than real mode.

The boost is significant and proven by the manual. When in virtual 8086 mode, INS iteration is 29 clocks and an OUTS is 28. If CPL <= IOPL, like with the ring 0 kernel, the IO takes a mere 8 clocks. That is potentially three times more performance per instruction minus the overhead of entering ring 0. For disk access involving many reads and writes, this is massive.

For example, reading a 512-byte sector, which is 256 IO operations, will take *approximately* 100 + 2048 clocks, with a hundred or more for the emulation overhead. If we did this with virtual 8086 mode, 7168 clocks would be used.

Setting the emulation policy is not possible because IOPL is always three and a zero allow bit in the IOPB would cause ring 3 IO to actually take place. For this reason, IO is __fully__ emulated under OS/90.

## Implementation

A boolean will decide if the emulation is direct or indirect. dosvm.md explains how indirect emulaton is done for virtual peripherals.

Direct emulation is implemented in assembly with a series of branches. The first two check for `rep insw` and `rep outsw`. The rest check for the following opcodes and run them:

```
INB imm8    E4 xx
INW imm8    E5 xx
OUTB imm8   E6 xx
INB DX      EC
INW DX      ED
OUTB DX     EE
INSB        6C
INSW        6D
OUTSB       6E
OUTSW       6F
```

Single operations using imm8 will run as the DX form.

32-bit IO is currently not supported under V86. String operations are also assumed to be with DF=0

# Interrupt Frame

Virtual 8086 mode automatically pushes the data segment registers but if we switched from protected mode then this will not occur. The segment registers have to be pushed manually.

# Thread States and Context Types (TODO)

OS/90 provides three contexts:
* User   (PM/RM)
* Kernel (PM)
* SV86   (RM)

The following thread states are supported:
```c
enum {
    THREAD_DEAD,
    THREAD_IN_KERNEL,
    THREAD_BLOCKED,
    THREAD_RUN_V86,
    THREAD_RUN_PM
};
```

# Scheduler Tick Interrupt

The scheduler tick interrupt is the core of the scheduler that makes decisions about which processes will run. It concurrently switches between the active threads of each process in the list.

Interrupts are completely turned off within this ISR as with all other IRQs. The low half saves all registers to a trap frame and passes a pointer to it. When the ISR is done, it pushes all the reigsters off of the stack.

## Process Hook Procedures

A process hook is a procedure called in an atomic context with the folowing signature:
```
PH_RET ProcessHook(PID pid)
```

PH_RET is a type which can be `PH_SKIP` or `PH_CONT`.

A function called InsertProcessHook(PID pid) inserts the hook procedure into the specified process. The reason the procedure takes the PID even though it is known when assigning the proc hook is because we may want to reuse the same code for several processes requesting the same service.

Process hooks should never block the process or change anything relating to its execution state. If it is blocked, how can you expect to unblock it? Instead, return PH_SKIP so that the scheduler does not run the process.

Process hooks are a hack meant to allow for simulating multiple addressing spaces in an OS that does not allow for them. It is primarily designed for emulating memory mapped IO for individual processes.

# Controlling Interrupts, Syncrhonization, and Preemption

To disable preemption, call the function PreemptInc() to increment the preempt counter. To go back to the previous call level, use PreemptDec(). When it is nonzero, the kernel cannot be preempted. These are functions because variables are never exported to drivers by the kernel. Disabling preemption will prevent any other threads from being scheduled until it becomes zero again. It can be used for synchronization between kernel threads since the operations are atomic and all other threads are suspended within the section, but could make the system sluggish if used unwisely.

Preemption can be enabled/disabled within a non-interruptible section. In the system entry, we do this to prevent the scehduler from scheduling the process before we have blocked it.

For disabling interrupts, use the macro SaveFlags() and RestoreFlags(). Disabling interrupts will make instructions inside the uninterruptible section fully atomic. If a resource is only used within a non-interruptible section, all access is synchronized.

Disabling interrupts will disable preemption as well.

```c
VOID IntendedUsage()
{
    PreemptInc();

    KeLogf("I cannot be preempted!\n\r");

    PreemptDec();
}
```

```c
VOID IntendedUsage()
{
    DWORD f;

    f = PushFlags()
    _CLI;

    // ...

    RestoreFlags(inf);
}
```
Never acquire a lock while interrupts are disabled, or the kernel will freeze forever! Remember that data can be protected by disabling interrupts or by locking, but both cannot be used. All clients of the protected data must agree to the same synchronization mechanism.

## Summary

OS/90 can synchronize concurrent data access by:
* Preemption off points
* Disabling interrupts
* Mutual exclusion lock

As long as one method is used consistently for the item being protected, each will work. Disabling interrupts is overkill for most situations except when doing programmed IO.

Mutual exclusion is the more common approach. It is best when the critical section is quite long and processes should be scheduled freely.

# Preemption Counter in Detail and Uses in Kernel

Decrementing the preemption counter is a viable synchronization method if the critical section is relatively short.

If the critical section is rather complex, a lock is better since it allows other tasks to run until they access the same resource.

## SV86

SV86 cannot be accessed by multiple tasks, so they will race to increment the counter atomically.

The reason why a lock is not used is because there is no need to allow other tasks the opportunity to run at all since they will be blocked later on anyway.

## Process List

Disabling preemption will acquire a critical section for the thread that increments the counter first. It will ensure that any non-isr code will not access the data. Operations on the preemption counter are always atomic.

### Accessing the Process List

When a process enters the system, it will be blocked with interrupts disabled. It will be automatically be unblocked by the system entry procedure.

# ISR and Kernel Reentrancy

The kernel is only reentrant in a preemptible context. An ISR can only call a function if it checks the locks that it uses and passes if one is acquired. Few functions are fully reentrant.

Some parts of the kernel such as the memory manager expose a function to check for reentrancy safety within an atomic context.

# System Entry Point

## Low SysEntry Handler

The trap frame is made to be identical for both protected mode and real mode.

The algorithm:
```
{
CALL_TABLE:
    ...
BEGIN:
    SavedEIP <- pop()

    if (stack[eflags].vm)
    {
        // No need to save sregs
    }
    else
    {
        push(data_sregs)
    }

    IsrIndex = (SavedEIP - Base of call Table) / sizeof(CtabEntry)

    HighSysEntry(IframeAddress, IsrIndex)

    if (stack[eflags].vm)
    {

    }
}

U32 SavedEIP
```

We must check the VM bit again because it could have changed (e.g. DPMI raw switch).



# Termination of a Process

For a process to fully terminate and leave the memory permanently, several steps need to be taken that require the cooperation of several subsystems.

All memory must be deallocated. Locked pages are forcefully unlocked and removed from the swap file.

# Executing Programs (TODO)

Executing processes does not require the filesystem. The same mechanism is used to create kernel threads.
```
Flags:
    EXEC_NOFILE
    EXEC_NEW_ENV

STATUS Execute(P_EXEC_STRUCT);
```

The parameter structure is:
```c
tstruct {
    PIMUSTR     name;
    PVOID       psp;
    PVOID       new_env;
    DWORD       flags;
};
```
