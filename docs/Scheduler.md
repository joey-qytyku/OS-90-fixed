# Preface

OS/90 features a fully-preemptible and reentrant kernel with support for multithreading and non-blocking IO.

## Terms to Know


Virtual INT: A feature in OS/90 that allows the kernel thread to enter real mode to call a software interrupt vector.

# PIT Configuration

Originally, 1MS scheduler ticks were considered, but when the kernel was made preemptive and reentrant, this was not nearly enough.

1MS means 1000 hertz. Let us suppose the average i386 runs at 20 MHz. It must be considered that the context switch procedure makes heavy use of memory access.

# Interrupts and Exceptions

Exceptions and interrupts are all indexed. A single byte value indicates the index of the E/I and a non-index bit indicates if it is an exception or IRQ. Every single IDT entry is ring 0. This is so that the local IDT can be used to implement local software interrupts.

Two functions in C dispatch exceptions or interrupts. They are called from C.

# Local Exceptions and Fake Interrupts

When any of these local asynchronous events take place, the scheduler will set a flag to indicate that the process is awaiting a fake IRQ or exception. On the next schedule of the process, it will change flow to enter that location.

If the program is in protected mode, a RETF frame is generated by the kernel so that the ISR can RETF back.

Knowing whether or not the process is busy processing an interrupt is the job of a device driver. The kernel will just call the vector.

The following exceptions may be hooked by DPMI programs:
* General protection fault
* Stack segment fault
* Divide by zero
* IRQ#13 or FPU error
* Debug
* Break
* Overflow
* Bound range
* Segment not present

#NP could be used by segmented model programs to implement virtual memory.

## Exceptions in Real Mode

Some programs trap exceptions such as divide by zero or FPU error. The local vectors are used for this if the entry has been set up properly.

IRQ#13 may be used to recieve FPU errors.

## IRQ#13

If a program sets this vector, it expects the FPU to be not be in native mode. The operating system will send FPU exceptions using the IRQ#13 vector.

# States of the CPU and Last Context Type (TODO)

The current context type is always known by the code running, but the kernel needs to know what it just switched out of.

The last context type can be:
* User
* Kernel
* Exception


# Processes

All processes are DPMI/DOS applications and can run in one of the following modes:
* Virtual 8086
* Protected mode 16-bit
* Protected mode 32-bit

A few DPMI functions are slightly different between 16 and 32-bit protected mode.

# What this Document is About

* How processes enter and exit the kernel
* Syhcronization
* Sending user-trapped events like IRQs and exceptions
* Virtual 8086 mode

# Synchronization

OS/90 makes use of non-reentrant locks. It is expected that all functions that require a lock to be acquired prior to calling document this. A function that acquires a lock should be the one that releases it.

# The Process Control Block

The PCB is 8192 bytes large and naturally aligned. It includes the stack and information about the process, both being 4096 bytes.

# Elevated Virtual 8086 Mode

## The Old Method and Why it is Wrong

It has been considered to have a specific context for virtual 8086 mode supervisor calls. This proved impractical for several reasons.

The first is that it wastes valuable process control block space and reduces cache locality. The second is that only one process can be in an elevated V86 state due to real mode non-reentrancy. This makes it even more wasteful. The third reason is that in order to make BIOS/DOS calls from the kernel, we need an entire reserved process control block so that the kernel can do this, which wastes an entire 8192 bytes that could be used better. The fourth and final reason is that most DOS calls are relatively short or do IO with interrupts disabled. Many BIOSes disable interrupts for certain calls, perhaps protect from reentrance. This means that multitasking latency is not really improved at all.

Whats more is that all these disadvantages come with very few potential advantages, but do increase the complexity of the scheduler.

## The Current Method

Entering virtual 8086 mode from the kernel is done by writing to a buffer containing the registers, saving callee-saved registers, and doing the whole entrance procedure with preemption disabled. Invocations of the INT instruction or IRET will accurately be simulated on the 16-bit stack.

Despite preemption being off on entry, the system entry function will decrement the preempt semaphore (knowing V86 increased it).

IRET will serve as a termination code.

# What is a Context

## Paging and Contexts

We do not use separate page directories for each process. Only a certain number of PDs are exposed to the process that can be used for program data. These are copied to a global page directory when context switching.

Switching to a kernel thread does load CR3 and flush TLB because kernel memory is always mapped to the same location.

# TSS and IO Permissions

OS/90 supports emulation of IO instructions for userspace software, but when the kernel needs to run virtual 8086 mode to perfrm system tasks, IO must be directly sent to hardware. There are two ways of doing this.

IOPL is going to be 3 for all tasks no matter what. Even though the CPL is less than or equal to the IOPL, it is still necessary to have an IOPB with all zeroes (allow) or there will be a fault and the instruction will not be directly executed. The IOPB is 8192 bytes long, but gives real mode code a performance boost because instructions run directly.

The other way to do it is to emulate all port IO. Decoding the instructions involves checking bits in the opcode that reveal different attributes, such as direction, imm8 or DX, or string/no string. These bits are not documented, but have predictable meanings and make decoding nothing more than a few condition checks.

This is best suited to full hardware virtualization by a device driver.

Directing them to real IO operations is a different story. We decode because emulating every possible instruction sequence would not be dense enough.

## Decision

The TSS may be a very large structure with the IOPB, but we will use it to simplify the IO virtualization functionality. Interpreting the IO instructions would cause the system to crawl during disk IO. 8K of wasted space is the cost of better performance.

But string operations may be faster due to bypassing security checks and IOPB. Additionally, protected mode IO calls are apparently faster, according to the 80386 Programmer's Manual. These are used by the BIOS to access ATA disks, but not floppies.

Perhaps we can do both by specifying the IO emulation strategy with the V86 handler.

# Low-level System Entry Point (SEP, LSEP)

The SEP is used for exceptions and system calls.

The system entry point can be called by a kernel thread at any time, but further processing is always needed to determine if the entrance is correct.

The exceptions and interrupts get separate vectors to differentiate between them. A sort of branch table is contructed with 16 bit call instructions that take the form of `66 E8 xx xx` . The equation `(EIP - TableBase) >> 2` will get the index of the event.

The 16-bit calls are not problematic for the linker because the actual instructions are hand coded to jump to the rest of the handler.

# Thread States (TODO, out of data)

OS/90 provides three contexts:
* User   (PM/RM)
* Kernel (PM)
* SV86   (RM)

These have their own register dump structures and entry/exit behavior. A process can only be in one of these. Only one process can be in virtual 8086 mode, however, due to the real mode lock.

## Definitions

Name|Number|Definition
-|-
PS_DEAD | Process is not running, PCB may be reclaimed
PS_V86  | Userspace real mode (virtual 8086)
PS_PM   | Userspace protected mode
PS_KERN | Inside kernel mode
PS_SV86 | Elevated virtual 8086 mode for BIOS/DOS calls

The reason why protected mode and virtual 8086 are a different state is because entering them is different. For PM, the segment registers must be set manually before entry, while for V86, they are pushed to the stack before calling IRET. The segment registers saved to the PCB are kept there because

## State Transitions and System Entry Point

## System Entry Point Implementation

The only thing the system entry point needs to know to enter the high level handler is if the task that caused the switch was in protected mode or V86. If we switched from V86, segment registers are saved to the stack. If we switched from protected mode, the segment registers except for SS need to be saved manually.

# Scheduler Tick Interrupt

The scheduler tick interrupt is the core of the scheduler that makes decisions about which processes will run. It concurrently switches between the active threads of each process in the list.

Interrupts are completely turned off within this ISR as with all other IRQs. The low half saves all registers to a trap frame and passes a pointer to it. When the ISR is done, it pushes all the reigsters off of the stack.

# Manual Yielding

Spinning in locks is an expensive operation that requires waiting until the next time slice. This is very inefficient, so it may be necessary to support voluntary preemption.

Yielding is no panacea. It is very expensive to switch context, especially in a tight loop. It can be done every few iterations, but that is not garaunteed to work well on every type of system.

# Procedures to Control Scheduler or Leave it to IRQ#0?

# Controlling Interrupts and Preemption

To disable preemption, call the function PreemptInc() to increment the preempt semaphore. To go back to the previous call level, use PreemptDec(). When it is nonzero, the kernel cannot be preempted. These are functions because variables are never exported to drivers by the kernel.

For disabling interrupts, use the macro SaveFlags() and RestoreFlags(). Disabling interrupts will make instructions inside the uninterruptible section fully atomic. If a resource is only used within a non-interruptible section, all access is synchronized.

Disabling interrupts will disable preemption as well.

```c
VOID IntendedUsage()
{
    PreemptInc();

    KeLogf("I cannot be preempted!\n\r");

    PreemptDec();
}
```

```c
VOID IntendedUsage()
{
    DWORD f;

    f = PushFlags()
    _CLI;

    // ...

    RestoreFlags(inf);
}
```


Never acquire a lock while interrupts are disabled, or the kernel could freeze forever! Remember that data can be protected by disabling interrupts or by locking. Both cannot be used. All clients of the protected data must agree to the same synchronization mechanism!

# Executing Programs

Executing processes does not require the filesystem. The same mechanism is used to create kernel threads.
```
Flags:
    EXEC_NOFILE
    EXEC_NEW_ENV

STATUS Execute(P_EXEC_STRUCT);
```

The parameter structure is:
```
tstruct {
    PIMUSTR     name;
    PVOID       psp;
    PVOID       new_env;
    DWORD       flags;
};
```
