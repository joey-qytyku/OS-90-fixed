# Preface

KERNL386 has the following properties:
* Preemptive multitasking using time slices
* Non-preemtible kernel
* Non-reentrant

## Terms to Know

Trap frame: When any sort of switch to kernel mode takes place, the registers will be saved on the stack.

Requester/focus/current process: The process to whom the trap frame belongs to. This process is the one that invoked the kernel or was interrupted by an IRQ or exception.

# Interrupts and Exceptions

Exceptions and interrupts are all indexed. A single byte value indicates the index of the E/I and a non-index bit indicates if it is an exception or IRQ. Every single IDT entry is ring 0. This is so that the local IDT can be used to implement local software interrupts.

Two functions in C dispatch exceptions or interrupts. They are called from C.

# Local Exceptions and Fake Interrupts

When any of these local asynchronous events take place, the scheduler will set a flag to indicate that the process is awaiting a fake IRQ or exception. On the next schedule of the process, it will change flow to enter that location.

If the program is in protected mode, a RETF frame is generated by the kernel so that the ISR can RETF back.

Knowing whether or not the process is busy processing an interrupt is the job of a device driver. The kernel will just call the vector.

## Exceptions in Real Mode

Some programs trap exceptions such as divide by zero or FPU error. The local vectors are used for this if the entry has been set up properly.

IRQ#13 may be used to recieve FPU errors.

## IRQ#13

If a program sets this vector, it expects the FPU to be in native mode. The operating system will send FPU exceptions using the IRQ#13 vector.

# Process Control Block

The PCB is a structure called THREAD which contains the register dump and various information about the process. It is garaunteed to be 4096 bytes long and no larger. The PID is the program segment prefix of the program.

The register dump should never be modified if the process is in focus because when IRQ#0 returns, it will not actually restore that context.

# Processes

All processes are DPMI/DOS applications and can run in one of the following modes:
* Virtual 8086
* Protected mode 16-bit
* Protected mode 32-bit

# Events

I should change the event system. Maybe I can make the kernel non-reentrancy less of an issue.

# Worker Threads

The kernel has a reserve of private worker threads. These threads are invisible to the rest of the system, but are executed with every scheduler tick. Worker threads can be requested by the kernel API. The callback will run once and is pre-emtible. The thread takes a single PVOID argument.

Worker threads can safely call kernel procedures with no concerns of reentrancy.

Some IO operations are tied to worker threads, which produces latency due to having to wait for the next IRQ#0 for it to be scheduled. The advantage is enhanced multitasking.

# IRQ#0

## PIT COnfiguration

The timer is configured to fire much faster than default, as the default 18.4 Hz frequency is pathetic for multitasking. Currently it is 1 tick per milisecond, but this can be made even higher.

## Time Slices

There are two variables:
time_slice
counter

counter is initialized to the same value as time_slice when a process starts. Every tick reduces the counter by 1. When counter is found to be zero on another IRQ, counter is reassigned to time_slice.

# Fibers

Kernel threads are impossible to implement in a non-reentrant and non-preempting kernel, so a different strategy is used. A fiber is a cooperatively tasked version of a thread. They are lightweight and easy to implement. Fibers allow different parts of the kernel space software to give each other time to perform a task without blocking the system.

The first fiber is the kernel itself. The fibers form a chain and the chain is executed by an IRQ#0 only if the IRQ#0 interrupted user code. If the IRQ#0 interrupted kernel code, it will not run the fibers. This ensures safe reentrance of kernel API calls.

The register dump of the fiber is slightly different because the segments do not need to be stored. The flags are saved, however.

An OS/90 fiber is represented by a structure called KERNEL_FIBER. It contains a simple register dump, local store buffer, and pointer to the next fiber. The fiber procedure takes a pointer to its structure and a pointer to its local storage. The stack pointer in the saved context points to the one provided in this structure. The stack of a fiber is restricted to 256 bytes.

## Fiber Local Storage (FLS)

Fibers may be instances of the same procedure, so a method of storing local variables is provided. The first parameter to a fiber is a void pointer to the FLS, which can be replaced by a structure pointer if desired. This means that a procedure can be written without having to access the FLS in the fiber structure directly. The FLS is garaunteed to be 128 bytes long.

## Uses of Fibers

A fiber can be used to do certain IO or call API functions that an ISR cannot.

## Implementation Details

### Yield

The yield command will use the fiber struct pointer to get the address of the context to switch from. Returning with a FIB_YIELD will save the context and let the fiber controller execute the next fiber.

## Examples

```c

KERNEL_FIBER kf;

//
// This fiber will never terminate.
//
VOID FiberProc(PKERNEL_FIBER self, PVOID fls)
{
    KeLogf("Hello, fiber world!\n\r");
    while (1) return FIB_YIELD;
}

VOID SetupFiber()
{
    STATUS stat = ScRegisterFiber(&kf, FiberProc);
    if (stat == OS_ERROR_GENERIC)
    {
        KeLogf("Failed to register fiber\n\r");
    }
}

```

## Fiber Control

Saving the context requires pushing many values to the stack, which is not efficient. The call instruction allows us to save the

# Starting the Scheduler

During initialization, interrupts will be disabled. They are only enabled if a DOS/BIOS call is made and it enabled the interrupts. The flags are saved.

The kernel exits the KernelMain function and goes back to IA32.asm, with the stack being completely empty. Then, IA32.asm loads the context of the first process into registers and uses IRET to enter the process. From now on the kernel will only run upon an interrupt of some sort.

# IO Scheduling

DOS has the following predefined file handles:
* STDIN  (0)
* STDOUT (1)
* STDERR (2)
* STDAUX (3)
* STDPRN (4)
The direct console IO command probably uses a .SYS driver interface.

Character IO calls operate on one of these handles. The problem with the DOS IO functions is that they are obviously not multitasking and only one thread can safely perform IO. This would be okay if blocking the entire system and giving DOS complete control was an acceptable way to handle IO, which it is not for OS/90. When a program requests IO, only that program should be blocked. DOS will have no involvement whatsover in input and output processing by default except for normal files.

This requires special scheduler support. When a process is waiting for an IO operation, the scheduler should not execute it until it finishes.

For example: Process A is trying to print "Hello, world!" on the screen. Process B is waiting for user input using STDIO. When the INT 21H is sent, the kernel will trap it. The processes will be blocked after each call. But how should the IO actually be performed? Any attempt to access the default file handles is now the responsibility of OS/90 and DOS has no involvement.

# Sub-processes

DOS allows programs to create subprocesses. A subprocess can be "executed" simply by loading it in memory as an overlay or creating a new process with its own PSP. Despite having their own program segment prefixes, subprocesses are not independent programs and do not get their own process control blocks. This is the correct behavior because DOS subprograms run like a stack, where exiting a process is like popping from it.

Protected mode DOS programs cannot execute subprocesses and will be terminated in this case.

# Reenterancy of the Kernel

The kernel is non-reentrant, meaning only one thread can run in kernel mode. Non-reentrancy means that a piece of code will break if it is interrupted by another invokation of itself in another thread. ISR's are fully atomic and do not reenter, but exceptions can interrupt ISRs and vice versa. We need to be able to call certain functions within interrupt contexts that cannot be implemented in a pure reentrany way, so a simple critical section is used by the callee. Interrupts are blocked while inside, which makes reentrance completely impossible and allows non-reentrant routines to be called from interrupts. Some functions can be safely called from an ISR and are marked with an ASYNC_APICALL in their header declaraction. Within an interrupt service routine, only such functions may be called.

Critical sections are implemented as the following:
```c
#define KeUseCritical DWORD __critical_eflags

#define KeBeginCritSec \
    __asm__ volatile(              \
        "pushfd" ASNL              \
        "pop %0" ASNL              \
        "cli"                      \
        :"=rm"(__critical_eflags)::);

#define KeEndCritSec \
    __asm__ volatile(\
        "push %0" ASNL\
        "popfd"   ASNL\
        ::"rm"(__critical_eflags));

```

Example of this being used:
```c
PTHREAD ASYNC_APICALL ScGetCurrentPCB(VOID)
{
    PTHREAD ret;
    UseCritical;

    KeBeginCritSec;
    ret = current_pcb;
    KeEndCritSec;

    return ret;
}
```

Using a critical section to run a non-reentrant kernel function from an interrupt does NOT garauntee safety, because the non-reentrant function may have began to execute and interrupts were not off when it started. Any exception generated from a critical section will potentially jeopardize the atomic nature of the section.

Not all asynconous events have atomic context concerns. For example, the system call ISR can call whatever functions it wants to because it will only be called by the user.

Memory allocation, for example, cannot be invoked in an ISR, so it is not implemented with critical sections.

# Interrupt Service Routines

An ISR is defined as a routine that runs when the CPU calls an IDT entry. There are three sources of interruptions:
* Exception
* Software interrupt
* External hardware

IRQs are index dispatched and use high-level handlers. From an IRQ ISR, the kernel is not reentrant.
IRQs are a restricted context. The may not:
* Cause a fault
* Access virtual memory
* Allocate memory
* Call any function that is not marked ASYNC
* Enable interrupts

An asynchronous event does not imply non-reentrancy of the kernel. In the case of exceptions, they can reenter if they switched from userspace. If the kernel were to, for example, cause a page fault by accessing virtual memory, there is no possibility of reentrancy issues since virtual memory functions use critical sections when needed.

Software interrupts can be called directly by userspace only and are always reentrant-safe.

## PIC Emulation

The programmable interrupt controller must be emulated to a certain degree because software that uses an IRQ will have to communicate with it directly. ICWs are currently ignored, but the IMR and ISR are supported. EOI has no special significance.
