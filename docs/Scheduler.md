# Preface

OS/90 features a fully-preemptible and reentrant kernel. The scheduler is the most complex part of OS/90 because of the high degree of DOS compatibility and modern features built on top of it.

# Terms to Know

Virtual INT: A feature in OS/90 that allows the kernel thread to enter real mode to call a software interrupt vector. This is terminated by the IRET instruction at the highest INT call level.

Reentrant: The kernel can be entered by several concurrent threads at once. Locking is used to guard parts of the kernel that are shared or non-reentrant.

Trap frame and context: Read below

# PIT Configuration

Originally, 1MS scheduler ticks were considered, but when the kernel was made preemptive and reentrant, this was found to not be very high.

1MS means 1000 hertz. Let us suppose the average i386 runs at 20 MHz. Context switches are expensive operations.

# Interrupts and Exceptions

# Local Exceptions and Fake Interrupts

When any of these local asynchronous events take place, the scheduler will set a flag to indicate that the process is awaiting a fake IRQ or exception. On the next schedule of the process, it will change flow to enter that location.

If the program is in protected mode, a RETF frame is generated by the kernel so that the ISR can RETF back.

Knowing whether or not the process is busy processing an interrupt is the job of a device driver. The kernel will just call the vector.

The following exceptions may be hooked by DPMI programs:
* General protection fault
* Stack segment fault
* Divide by zero
* IRQ#13 or FPU error
* Debug
* Break
* Overflow
* Bound range
* Segment not present

#NP could be used by segmented model programs to implement segment swapping.

## Exceptions in Real Mode

Some programs trap exceptions such as divide by zero or FPU error. The local vectors are used for this if the entry has been set up properly.

IRQ#13 may be used to recieve FPU errors.

## IRQ#13

If a program sets this vector, it expects the FPU to be not be in native mode. The operating system will send FPU exceptions using the IRQ#13 vector.

# States of the CPU and Last Context Type (TODO)

The current context type is always known by the code running, but the kernel needs to know what it just switched out of.

The last context type can be:
* User
* Kernel
* Exception

# Processes

All processes are DPMI/DOS applications and can run in one of the following modes:
* Virtual 8086
* Protected mode 16-bit
* Protected mode 32-bit

A few DPMI functions are slightly different between 16 and 32-bit protected mode.

# What this Document is About

* How processes enter and exit the kernel
* How tasks are switched
* Syhcronization
* Sending user-trapped events like IRQs and exceptions
* Virtual 8086 mode

# Synchronization

OS/90 makes use of non-reentrant locks. It is expected that all functions that require a lock to be acquired prior to calling document this. A function that acquires a lock should be the one that releases it.

# The Process Control Block

The PCB is 8192 bytes large and naturally aligned. It includes the stack and information about the process, both being 4096 bytes.

# Elevated Virtual 8086 Mode (SV86)

# Contexts

## Non-Preemptible Context

A non-preemptible context is a section of execution within kernel mode which cannot be interrupted by a user process. Entering one is done by inc/dec'ing the preempt counter (read below). Disabling interrupts implies a non-preemtible region. A non-preemtible context is the only type of context in which the trap frame can be safely read or written. Returning from the system entry and back to the original code is valid behavior.

SV86 and exceptions are non-preemtible contexts.

## Preemptible Context

Processes when in user or kernel mode are preemptible.

# TSS and IO Permissions

OS/90 supports emulation of IO instructions for userspace software, but when the kernel needs to run virtual 8086 mode to perform system tasks, IO must be directly sent to hardware. There are two ways of doing this.

IOPL is going to be 3 for all tasks no matter what. Even though the CPL is less than or equal to the IOPL, it is still necessary to have an IOPB with all zeroes (allow) or there will be a fault and the instruction will not be directly executed. The IOPB is 8192 bytes long, but gives real mode code a performance boost because instructions run directly. Or so it seems.

The other way to do it is to emulate all port IO. Decoding the instructions involves checking bits in the opcode that reveal different attributes, such as direction, imm8 or DX, or string/no string. These bits are not documented, but have predictable meanings and make decoding nothing more than a few condition checks and bit masks.

Directing them to real IO operations is a different story. We decode because emulating every possible instruction sequence would not be dense enough.

## Decision

The TSS may be a very large structure with the IOPB, but we will use it to simplify the IO virtualization functionality. Interpreting the IO instructions would cause the system to crawl during IO. 8K of memory is the cost of better performance.

But IO opcodes are faster in ring-0 protected mode because they do not need to access the IOPB or check IOPL. String instructions justify emulation overhead. Protected mode IO is apparently faster than real mode.

The boost is significant and proven by the 80386 manual. When in virtual 8086 mode, INS iteration is 29 clocks and an OUTS is 28. If CPL <= IOPL, like with the ring 0 kernel, the IO takes a mere 8 clocks. That is potentially three times more performance per instruction minus the overhead of entering ring 0. For disk access involving many reads and writes, this is massive.

For example, reading a 512-byte sector, which is 256 IO operations, will take *approximately* 100 + 2048 clocks, with a hundred or more for the emulation overhead. If we did this with virtual 8086 mode, 7168 clocks would be used.

Setting the emulation policy is not possible because IOPL is always three and a zero allow bit in the IOPB would cause ring 3 IO to actually take place.

> Long story short, IO is __fully__ emulated under OS/90. This is done within a __non-preemptible context__.

## Implementation

A boolean will decide if the emulation is direct or indirect. dosvm.md explains how indirect emulaton is done for virtual peripherals.

Direct emulation is implemented in assembly with a series of branches. The first two check for `rep insw` and `rep outsw`. The rest check for the following opcodes and run them:

```
INB imm8    E4 xx
INW imm8    E5 xx
OUTB imm8   E6 xx
INB DX      EC
INW DX      ED
OUTB DX     EE
INSB        6C
INSW        6D
OUTSB       6E
OUTSW       6F
```

Single operations using imm8 will run as the DX form.

> 32-bit IO is currently not supported under V86. String operations are also assumed to be with DF=0

# The IRET Frame

When a switch from ring-3 to ring-0 takes place, the kernel will have an system entry procedure that will save registers onto the stack and call a higher level procedure.

This is a complicated matter. If a switch happens from V86, the segment registers will automatically be saved onto the stack before the rest can be. This means that the IRET frame structure will have two sets of segment registers.

This is not a problem. Regardless of the previous mode, segment registers are always pushed and popped after the system entry is finished. This can have the effect of restoring the ring-3 protected mode state's segment registers or zeroing them out as specified by V86. IRET will check EFLAGS and decide based on that.

What this all means is that code that modifies the trap frame directly--particularly the segment registers--must know what mode the context was in. The VM flag is all this is needed, though checking the process type ID works too.

## For IRQs and Exceptions

Exceptions use system entry and are subject to the same rules as software interrupts. The only difference is that exceptions are non-preemptible.

IRQs use the same entry/return method but do not go through system entry.

# Thread States and Context Types (TODO)

OS/90 provides three contexts:
* User   (PM/RM)
* Kernel (PM)
* SV86   (RM)

The following thread states are supported:
```c
enum {
    THREAD_DEAD,
    THREAD_IN_KERNEL,
    THREAD_BLOCKED,
    THREAD_RUN_V86,
    THREAD_RUN_PM
};
```

# Scheduler Tick Interrupt

The scheduler tick interrupt is the core of the scheduler that makes decisions about which processes will run. It concurrently switches between the active threads of each process in the list.

Interrupts are completely turned off within this ISR as with all other IRQs. The low half saves all registers to a trap frame and passes a pointer to it. When the ISR is done, it pushes all the reigsters off of the stack.

## Process Hook Procedures

A process hook is a procedure called in an atomic context with the folowing signature:
```
PH_RET ProcessHook(PID pid)
```

PH_RET is a type which can be `PH_SKIP` or `PH_CONT`.

A function called InsertProcessHook(PID pid) inserts the hook procedure into the specified process. The reason the procedure takes the PID even though it is known when assigning the proc hook is because we may want to reuse the same code for several processes requesting the same service.

Process hooks should never block the process or change anything relating to its execution state. If it is blocked, how can you expect to unblock it? Instead, return PH_SKIP so that the scheduler does not run the process.

Process hooks are a hack meant to allow for simulating multiple addressing spaces in an OS that does not allow for them. It is primarily designed for emulating memory mapped IO for individual processes.

# Controlling Interrupts, Syncrhonization, and Preemption

OS/90 supports the ATOMIC type which behaves outwardly as a counter or boolean lock, depending on how it is used.

The following operations are supported and are done in a single instruction for atomicity:
* Increment: AtomicFencedInc
* Decrement: AtomicFencedDec
* Load:      AtomicFencedLoad
* Store:     AtomicFencedStore
* Compare:   AtomicFencedCompare
* Acquire:   AcquireMutex
* Release:   ReleaseMutex

These are implemented as macros/inline.

# Preemption Counter in Detail and Uses in Kernel

The preeption counter is not really a recursive mutex. It is a single atomic variable that has the special meaning of blocking all threads except the currently running one (kernel).

Decrementing the preemption counter is a viable synchronization method if the critical section is relatively short.

If the critical section is rather complex, a lock is better since it allows other tasks to run until they access the same resource.

## SV86

SV86 cannot be accessed by multiple tasks, so they will race to increment the preempt counter atomically.

A global variable called `g_sv86`  determines if the kernel should handle INT/IRET and other opcodes for SV86 or for V86 processes.

The reason why a lock is not used is because there is no need to allow other tasks the opportunity to run at all since they will be blocked later on anyway.

SV86 cannot be entered unless IOPL=0. This is different than the usual IOPL=3 for regular processes and garauntees that only the #GP handler will deal with INT opcodes within its non-preempible context. This separates SV86 from the more complicated handling of INT for protected mode.

### SV86 Interrupts

SV86 can be interrupted by SV86. The interrupt handler will call NOT call `EnterV86` since it cannot nest, but instead will change the control flow of the SV86 context with stack emulation.

The process is as follows:
* Kernel enters SV86
* Interrupt is recieved and kernel needs to reflect
* ISR handler realizes saved context is SV86
* ISR handler calls a function that emulates the stack behavior of an IRQ.
* ISR handler returns and executes the real mode ISR. It has no control after this point.
* Real mode ISR executes `INT VEC_IRET_SV86`
* IRET stack behavior
* Computer continues executing in SV86

Stack emulation for a RECL_16 IRQ while inside SV86 is different because it requires IF=0 on entry, but is identical otherwise.

## Process List

Disabling preemption will acquire a critical section for the thread that increments the counter first. It will ensure that any non-isr code will not access the data.

When a process enters the system, it will be blocked with interrupts disabled. It will be automatically be unblocked by the system entry procedure.

# INT Capture

INT capturing must work with SV86 and regular processes. The same procedure is called in both in either case. If different behavior is required depending on the context type, it is necessary to know what the current context type is.

The INT capture structure contains a handler for SV86 and user V86. Both __must__ be provided. It cannot be the same procedure.

> todo: add a check preempt zero operation. Make SV86 regs and proc regs somewhat compatible? Why would they be though?

# ISR and Kernel Reentrancy

The kernel is only reentrant in a preemptible context. An ISR can only call a function if it checks the locks that it uses and passes if one is acquired. Few functions are fully reentrant.

Some parts of the kernel such as the memory manager expose a function to check for reentrancy safety within an atomic context.

# System Entry Point

There are difficulties with getting exceptions to work using the direct IDT approach. Calling an exception handler with INT is not possible and will cause an error. The problem is that DPMI requires all INT calls to go directly to real mode by default. This means that it is possible to call a vector overlapping with an exception handler. Yuck.

OS/90 has a way of handling this. When it enters the high level system entry function, interrupts are off and the context is atomic and non-preemptible. The function is passed an event code which differentiates between exceptions and INTs. There is not need to check for the INT opcode.

User V86 and protected mode (16/32-bit) have different ways of simulating the INT instruction. It can be done as a trap or an IRQ.

```
```

# Termination of a Process

For a process to fully terminate and leave the memory permanently, several steps need to be taken that require the cooperation of several subsystems.

All memory must be deallocated. Locked pages are forcefully unlocked and removed from the swap file.
