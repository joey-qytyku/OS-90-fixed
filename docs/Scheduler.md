# Preface

OS/90 features a fully-preemptible and reentrant kernel. The scheduler is the most complex part of OS/90 because of the high degree of DOS compatibility.

# Terms to Know

Virtual INT: A feature in OS/90 that allows the kernel thread to enter real mode to call a software interrupt vector. This is terminated by the IRET instruction at the highest INT call level.
Reentrant: The kernel can be entered by several concurrent threads at once. Locking is used to guard parts of the kernel that are shared or non-reentrant
Trap frame and context: Read below

# PIT Configuration

Originally, 1MS scheduler ticks were considered, but when the kernel was made preemptive and reentrant, this was found to not be very high.

1MS means 1000 hertz. Let us suppose the average i386 runs at 20 MHz. Context switches are expensive operations.

# Interrupts and Exceptions

# Local Exceptions and Fake Interrupts

When any of these local asynchronous events take place, the scheduler will set a flag to indicate that the process is awaiting a fake IRQ or exception. On the next schedule of the process, it will change flow to enter that location.

If the program is in protected mode, a RETF frame is generated by the kernel so that the ISR can RETF back.

Knowing whether or not the process is busy processing an interrupt is the job of a device driver. The kernel will just call the vector.

The following exceptions may be hooked by DPMI programs:
* General protection fault
* Stack segment fault
* Divide by zero
* IRQ#13 or FPU error
* Debug
* Break
* Overflow
* Bound range
* Segment not present

#NP could be used by segmented model programs to implement segment swapping.

## Exceptions in Real Mode

Some programs trap exceptions such as divide by zero or FPU error. The local vectors are used for this if the entry has been set up properly.

IRQ#13 may be used to recieve FPU errors.

## IRQ#13

If a program sets this vector, it expects the FPU to be not be in native mode. The operating system will send FPU exceptions using the IRQ#13 vector.

# States of the CPU and Last Context Type (TODO)

The current context type is always known by the code running, but the kernel needs to know what it just switched out of.

The last context type can be:
* User
* Kernel
* Exception

# Processes

All processes are DPMI/DOS applications and can run in one of the following modes:
* Virtual 8086
* Protected mode 16-bit
* Protected mode 32-bit

A few DPMI functions are slightly different between 16 and 32-bit protected mode.

# What this Document is About

* How processes enter and exit the kernel
* Syhcronization
* Sending user-trapped events like IRQs and exceptions
* Virtual 8086 mode

# Synchronization

OS/90 makes use of non-reentrant locks. It is expected that all functions that require a lock to be acquired prior to calling document this. A function that acquires a lock should be the one that releases it.

# The Process Control Block

The PCB is 8192 bytes large and naturally aligned. It includes the stack and information about the process, both being 4096 bytes.

# Elevated Virtual 8086 Mode (SV86)

# Context and Trap Frame

## Trap Frame Definition

In the source code, the trap frame is called the "iret frame," but it refers to the same thing. The trap frame is the registers saved to the stack for interrupt and system entry. Because OS/90 has a preemtible kernel, the trap frame only reflects the state of the invoking process as long as interrupts are disabled and preemption is off by proxy. The trap frame must be copied onto the process control block for processes.

## Non-Preemptible Context

A non-preemptible context is a section of execution within kernel mode which cannot be interrupted by a user process. Entering one is done by inc/dec'ing the preempt counter (read below). Disabling interrupts implies a non-preemtible region. A non-preemtible context is the only type of context in which the trap frame can be safely read or written. Returning from the system entry and back to the original code is valid behavior.

SV86 and exceptions are non-preemtible contexts.

## Preemptible Context

Processes when in user or kernel mode are preemptible.

## Paging and Contexts

We do not use separate page directories for each process. Only a certain number of PDs are exposed to the process that can be used for program data. These are copied to a global page directory when context switching.

Switching to a kernel thread does load CR3 and flush TLB because kernel memory is always mapped to the same location.

# TSS and IO Permissions

OS/90 supports emulation of IO instructions for userspace software, but when the kernel needs to run virtual 8086 mode to perform system tasks, IO must be directly sent to hardware. There are two ways of doing this.

IOPL is going to be 3 for all tasks no matter what. Even though the CPL is less than or equal to the IOPL, it is still necessary to have an IOPB with all zeroes (allow) or there will be a fault and the instruction will not be directly executed. The IOPB is 8192 bytes long, but gives real mode code a performance boost because instructions run directly. Or so it seems.

The other way to do it is to emulate all port IO. Decoding the instructions involves checking bits in the opcode that reveal different attributes, such as direction, imm8 or DX, or string/no string. These bits are not documented, but have predictable meanings and make decoding nothing more than a few condition checks and bit masks.

Directing them to real IO operations is a different story. We decode because emulating every possible instruction sequence would not be dense enough.

## Decision

The TSS may be a very large structure with the IOPB, but we will use it to simplify the IO virtualization functionality. Interpreting the IO instructions would cause the system to crawl during IO. 8K of memory is the cost of better performance.

But IO opcodes are faster in ring-0 protected mode because they do not need to access the IOPB or check IOPL. String instructions justify emulation overhead. Protected mode IO is apparently faster than real mode.

The boost is significant and proven by the manual. When in virtual 8086 mode, INS iteration is 29 clocks and an OUTS is 28. If CPL <= IOPL, like with the ring 0 kernel, the IO takes a mere 8 clocks. That is potentially three times more performance per instruction minus the overhead of entering ring 0. For disk access involving many reads and writes, this is massive.

For example, reading a 512-byte sector, which is 256 IO operations, will take *approximately* 100 + 2048 clocks, with a hundred or more for the emulation overhead. If we did this with virtual 8086 mode, 7168 clocks would be used.

Setting the emulation policy is not possible because IOPL is always three and a zero allow bit in the IOPB would cause ring 3 IO to actually take place. For this reason, IO is fully emulated under OS/90.

## Implementation

A boolean will decide if the emulation is direct or indirect. dosvm.md explains how indirect emulaton is done for virtual peripherals.

Direct emulation is implemented in assembly with a series of branches. The first two check for `rep insw` and `rep outsw`. The rest check for the following opcodes and run them:

```
INB imm8    E4 xx
INW imm8    E5 xx
OUTB imm8   E6 xx
INB DX      EC
INW DX      ED
OUTB DX     EE
INSB        6C
INSW        6D
OUTSB       6E
OUTSW       6F
```

Single operations using imm8 will run as the DX form.

32-bit IO is currently not supported under V86. String operations are also assumed to be with DF=0


# Thread States and Contexts (TODO)

OS/90 provides three contexts:
* User   (PM/RM)
* Kernel (PM)
* SV86   (RM)

The following thread states are supported:
```c
enum {
    THREAD_DEAD,
    THREAD_IN_KERNEL,
    THREAD_BLOCKED,
    THREAD_RUN_V86,
    THREAD_RUN_PM
};
```

# Scheduler Tick Interrupt

The scheduler tick interrupt is the core of the scheduler that makes decisions about which processes will run. It concurrently switches between the active threads of each process in the list.

Interrupts are completely turned off within this ISR as with all other IRQs. The low half saves all registers to a trap frame and passes a pointer to it. When the ISR is done, it pushes all the reigsters off of the stack.

# Controlling Interrupts and Preemption

To disable preemption, call the function PreemptInc() to increment the preempt counter. To go back to the previous call level, use PreemptDec(). When it is nonzero, the kernel cannot be preempted. These are functions because variables are never exported to drivers by the kernel. Disabling preemption will prevent any other threads from being scheduled until it becomes zero again. It can be used for syncrhonization between kernel threads since the operations are atomic and all other threads are suspended within the section, but could make the system sluggish if used unwisely.

Preemption can be enabled/disabled within a non-interruptible section. In the system entry, we do this to prevent the scehduler from scheduling the process before we have blocked it.

For disabling interrupts, use the macro SaveFlags() and RestoreFlags(). Disabling interrupts will make instructions inside the uninterruptible section fully atomic. If a resource is only used within a non-interruptible section, all access is synchronized.

Disabling interrupts will disable preemption as well.

```c
VOID IntendedUsage()
{
    PreemptInc();

    KeLogf("I cannot be preempted!\n\r");

    PreemptDec();
}
```

```c
VOID IntendedUsage()
{
    DWORD f;

    f = PushFlags()
    _CLI;

    // ...

    RestoreFlags(inf);
}
```
Never acquire a lock while interrupts are disabled, or the kernel could freeze forever! Remember that data can be protected by disabling interrupts or by locking. Both cannot be used. All clients of the protected data must agree to the same synchronization mechanism.

# Process List

The process list lock must be acquired before making any changes to the process list except in one specific instance in the kernel. In the system entry procedure, the stack is used to calculate the location of the PCB. It can be safely accessed here regardless of the state of the lock.

# System Entry Point

To control access to real mode, `v86_chain_lock` must be acquired. This prevents instances of Int16 from colliding with modifications to the INT chain. If `v86_chain_lock` is acquired, then the last context was non-preemtible virtual 8086 mode. The act of entering virtual 8086 mode to do a supervisory service call merely requires disabling preemption.

# Termination of a Process

For a process to fully terminate and leave the memory permanently, several steps need to be taken that require the cooperation of several subsystems.

All memory must be deallocated. Locked pages are forcefully unlocked and removed from the swap file.

# Executing Programs (TODO)

Executing processes does not require the filesystem. The same mechanism is used to create kernel threads.
```
Flags:
    EXEC_NOFILE
    EXEC_NEW_ENV

STATUS Execute(P_EXEC_STRUCT);
```

The parameter structure is:
```
tstruct {
    PIMUSTR     name;
    PVOID       psp;
    PVOID       new_env;
    DWORD       flags;
};
```
